# üìä CCXT Integration Service for ChartGenius
# –í–µ—Ä—Å–∏—è: 1.1.0-dev
# –ü–æ—ç—Ç–∞–ø–Ω–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è CCXT –¥–ª—è market data

import asyncio
import logging
from typing import Dict, Any, List, Optional, Union
from datetime import datetime, timedelta
import ccxt.async_support as ccxt
import pandas as pd
from dataclasses import dataclass
from enum import Enum
import json

from backend.services.metrics_service import metrics
from backend.config.config import logger

class ExchangeStatus(Enum):
    """–°—Ç–∞—Ç—É—Å—ã –±–∏—Ä–∂"""
    HEALTHY = "healthy"
    DEGRADED = "degraded"
    UNAVAILABLE = "unavailable"

@dataclass
class ExchangeConfig:
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –±–∏—Ä–∂–∏"""
    name: str
    priority: int  # 1 = highest priority
    rate_limit: int  # requests per minute
    timeout: float = 30.0
    retry_attempts: int = 3

@dataclass
class MarketDataResponse:
    """–û—Ç–≤–µ—Ç —Å —Ä—ã–Ω–æ—á–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏"""
    symbol: str
    timeframe: str
    data: List[List[float]]  # OHLCV format
    source: str
    timestamp: datetime
    count: int

class CCXTService:
    """–°–µ—Ä–≤–∏—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å CCXT"""
    
    def __init__(self):
        self.exchanges: Dict[str, ccxt.Exchange] = {}
        self.exchange_configs: Dict[str, ExchangeConfig] = {}
        self.exchange_health: Dict[str, ExchangeStatus] = {}
        self.fallback_order: List[str] = []
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∏—Ä–∂
        self._initialize_exchanges()
    
    def _initialize_exchanges(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã—Ö –±–∏—Ä–∂"""
        configs = [
            ExchangeConfig(name='binance', priority=1, rate_limit=1200),
            ExchangeConfig(name='coinbase', priority=2, rate_limit=600),
            ExchangeConfig(name='kraken', priority=3, rate_limit=900),
            ExchangeConfig(name='bybit', priority=4, rate_limit=600),
        ]
        
        for config in configs:
            try:
                exchange_class = getattr(ccxt, config.name)
                exchange = exchange_class({
                    'enableRateLimit': True,
                    'timeout': config.timeout * 1000,  # CCXT expects milliseconds
                    'options': {
                        'defaultType': 'spot',  # spot trading
                    }
                })
                
                self.exchanges[config.name] = exchange
                self.exchange_configs[config.name] = config
                self.exchange_health[config.name] = ExchangeStatus.HEALTHY
                
                logger.info(f"Initialized exchange: {config.name}")
                
            except Exception as e:
                logger.error(f"Failed to initialize exchange {config.name}: {e}")
        
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ—Ä—è–¥–æ–∫ fallback –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—É
        self.fallback_order = sorted(
            self.exchange_configs.keys(),
            key=lambda x: self.exchange_configs[x].priority
        )
    
    async def get_ohlcv_data(self, symbol: str, timeframe: str = '4h', 
                           limit: int = 500, preferred_exchange: Optional[str] = None) -> Optional[MarketDataResponse]:
        """
        –ü–æ–ª—É—á–µ–Ω–∏–µ OHLCV –¥–∞–Ω–Ω—ã—Ö —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º fallback
        
        Args:
            symbol: –¢–æ—Ä–≥–æ–≤–∞—è –ø–∞—Ä–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 'BTC/USDT')
            timeframe: –í—Ä–µ–º–µ–Ω–Ω–æ–π –∏–Ω—Ç–µ—Ä–≤–∞–ª ('1m', '5m', '1h', '4h', '1d')
            limit: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–≤–µ—á–µ–π
            preferred_exchange: –ü—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º–∞—è –±–∏—Ä–∂–∞
            
        Returns:
            MarketDataResponse –∏–ª–∏ None –ø—Ä–∏ –æ—à–∏–±–∫–µ
        """
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ—Ä—è–¥–æ–∫ –ø–æ–ø—ã—Ç–æ–∫
        exchanges_to_try = []
        
        if preferred_exchange and preferred_exchange in self.exchanges:
            exchanges_to_try.append(preferred_exchange)
        
        # –î–æ–±–∞–≤–ª—è–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã–µ –±–∏—Ä–∂–∏ –ø–æ –ø–æ—Ä—è–¥–∫—É fallback
        for exchange_name in self.fallback_order:
            if exchange_name not in exchanges_to_try:
                exchanges_to_try.append(exchange_name)
        
        last_error = None
        
        for exchange_name in exchanges_to_try:
            # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã–µ –±–∏—Ä–∂–∏
            if self.exchange_health[exchange_name] == ExchangeStatus.UNAVAILABLE:
                logger.warning(f"Skipping unavailable exchange: {exchange_name}")
                continue
            
            try:
                logger.info(f"Attempting to fetch OHLCV from {exchange_name}")
                
                exchange = self.exchanges[exchange_name]
                config = self.exchange_configs[exchange_name]
                
                # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Å retry –ª–æ–≥–∏–∫–æ–π
                ohlcv_data = await self._fetch_with_retry(
                    exchange, symbol, timeframe, limit, config.retry_attempts
                )
                
                if ohlcv_data:
                    # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∑–¥–æ—Ä–æ–≤—å—è
                    self.exchange_health[exchange_name] = ExchangeStatus.HEALTHY
                    
                    # –¢—Ä–µ–∫–∏–Ω–≥ –º–µ—Ç—Ä–∏–∫
                    metrics.track_user_action('ccxt_data_fetch_success', 'system')
                    
                    return MarketDataResponse(
                        symbol=symbol,
                        timeframe=timeframe,
                        data=ohlcv_data,
                        source=exchange_name,
                        timestamp=datetime.utcnow(),
                        count=len(ohlcv_data)
                    )
                
            except Exception as e:
                last_error = e
                logger.warning(f"Exchange {exchange_name} failed: {e}")
                
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∑–¥–æ—Ä–æ–≤—å—è
                self._update_exchange_health(exchange_name, False)
                
                # –¢—Ä–µ–∫–∏–Ω–≥ –æ—à–∏–±–æ–∫
                metrics.track_error(type(e).__name__, 'ccxt_service')
                
                continue
        
        # –í—Å–µ –±–∏—Ä–∂–∏ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª–∏
        logger.error(f"All exchanges failed for {symbol}. Last error: {last_error}")
        metrics.track_user_action('ccxt_data_fetch_failed', 'system')
        return None
    
    async def _fetch_with_retry(self, exchange: ccxt.Exchange, symbol: str, 
                               timeframe: str, limit: int, max_retries: int) -> Optional[List[List[float]]]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —Å –ø–æ–≤—Ç–æ—Ä–Ω—ã–º–∏ –ø–æ–ø—ã—Ç–∫–∞–º–∏"""
        for attempt in range(max_retries):
            try:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–¥–µ—Ä–∂–∫—É —Å–∏–º–≤–æ–ª–∞
                if not await self._check_symbol_support(exchange, symbol):
                    logger.warning(f"Symbol {symbol} not supported on {exchange.id}")
                    return None
                
                # –ü–æ–ª—É—á–∞–µ–º OHLCV –¥–∞–Ω–Ω—ã–µ
                ohlcv = await exchange.fetch_ohlcv(symbol, timeframe, limit=limit)
                
                if ohlcv and len(ohlcv) > 0:
                    logger.info(f"Successfully fetched {len(ohlcv)} candles from {exchange.id}")
                    return ohlcv
                
            except ccxt.NetworkError as e:
                logger.warning(f"Network error on {exchange.id}, attempt {attempt + 1}: {e}")
                if attempt < max_retries - 1:
                    await asyncio.sleep(2 ** attempt)  # Exponential backoff
                    continue
                
            except ccxt.ExchangeError as e:
                logger.error(f"Exchange error on {exchange.id}: {e}")
                break  # –ù–µ –ø–æ–≤—Ç–æ—Ä—è–µ–º –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö –±–∏—Ä–∂–∏
                
            except Exception as e:
                logger.error(f"Unexpected error on {exchange.id}: {e}")
                break
        
        return None
    
    async def _check_symbol_support(self, exchange: ccxt.Exchange, symbol: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ —Å–∏–º–≤–æ–ª–∞ –Ω–∞ –±–∏—Ä–∂–µ"""
        try:
            # –ó–∞–≥—Ä—É–∂–∞–µ–º —Ä—ã–Ω–∫–∏ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
            if not exchange.markets:
                await exchange.load_markets()
            
            return symbol in exchange.markets
            
        except Exception as e:
            logger.error(f"Error checking symbol support: {e}")
            return False
    
    def _update_exchange_health(self, exchange_name: str, success: bool):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∑–¥–æ—Ä–æ–≤—å—è –±–∏—Ä–∂–∏"""
        if success:
            self.exchange_health[exchange_name] = ExchangeStatus.HEALTHY
        else:
            current_status = self.exchange_health[exchange_name]
            
            if current_status == ExchangeStatus.HEALTHY:
                self.exchange_health[exchange_name] = ExchangeStatus.DEGRADED
            elif current_status == ExchangeStatus.DEGRADED:
                self.exchange_health[exchange_name] = ExchangeStatus.UNAVAILABLE
    
    async def get_ticker_data(self, symbol: str, preferred_exchange: Optional[str] = None) -> Optional[Dict[str, Any]]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–∏—Ö —Ü–µ–Ω (ticker)"""
        exchanges_to_try = [preferred_exchange] if preferred_exchange else self.fallback_order
        
        for exchange_name in exchanges_to_try:
            if exchange_name not in self.exchanges:
                continue
                
            if self.exchange_health[exchange_name] == ExchangeStatus.UNAVAILABLE:
                continue
            
            try:
                exchange = self.exchanges[exchange_name]
                ticker = await exchange.fetch_ticker(symbol)
                
                if ticker:
                    self.exchange_health[exchange_name] = ExchangeStatus.HEALTHY
                    
                    return {
                        'symbol': ticker['symbol'],
                        'last': ticker['last'],
                        'bid': ticker['bid'],
                        'ask': ticker['ask'],
                        'volume': ticker['baseVolume'],
                        'change': ticker['change'],
                        'percentage': ticker['percentage'],
                        'timestamp': ticker['timestamp'],
                        'source': exchange_name
                    }
                
            except Exception as e:
                logger.warning(f"Ticker fetch failed on {exchange_name}: {e}")
                self._update_exchange_health(exchange_name, False)
                continue
        
        return None
    
    async def health_check_all(self) -> Dict[str, Dict[str, Any]]:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è –≤—Å–µ—Ö –±–∏—Ä–∂"""
        results = {}
        
        for exchange_name, exchange in self.exchanges.items():
            try:
                start_time = datetime.utcnow()
                
                # –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ - –ø–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –±–∏—Ä–∂–µ
                await exchange.fetch_status()
                
                response_time = (datetime.utcnow() - start_time).total_seconds()
                
                results[exchange_name] = {
                    'status': 'healthy',
                    'response_time': response_time,
                    'last_check': datetime.utcnow().isoformat()
                }
                
                self.exchange_health[exchange_name] = ExchangeStatus.HEALTHY
                
            except Exception as e:
                results[exchange_name] = {
                    'status': 'unhealthy',
                    'error': str(e),
                    'last_check': datetime.utcnow().isoformat()
                }
                
                self.exchange_health[exchange_name] = ExchangeStatus.UNAVAILABLE
        
        return results
    
    async def get_supported_symbols(self, exchange_name: Optional[str] = None) -> List[str]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤"""
        target_exchange = exchange_name or self.fallback_order[0]
        
        if target_exchange not in self.exchanges:
            return []
        
        try:
            exchange = self.exchanges[target_exchange]
            
            if not exchange.markets:
                await exchange.load_markets()
            
            # –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ USDT –ø–∞—Ä—ã –¥–ª—è –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç
            symbols = [
                symbol for symbol in exchange.markets.keys()
                if '/USDT' in symbol and not any(
                    excluded in symbol for excluded in ['BULL', 'BEAR', 'UP', 'DOWN']
                )
            ]
            
            return sorted(symbols)
            
        except Exception as e:
            logger.error(f"Error getting supported symbols: {e}")
            return []
    
    def get_exchange_stats(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –±–∏—Ä–∂"""
        stats = {
            'total_exchanges': len(self.exchanges),
            'healthy_exchanges': sum(
                1 for status in self.exchange_health.values() 
                if status == ExchangeStatus.HEALTHY
            ),
            'exchange_details': {}
        }
        
        for exchange_name in self.exchanges.keys():
            config = self.exchange_configs[exchange_name]
            health = self.exchange_health[exchange_name]
            
            stats['exchange_details'][exchange_name] = {
                'status': health.value,
                'priority': config.priority,
                'rate_limit': config.rate_limit,
                'timeout': config.timeout
            }
        
        return stats
    
    async def close_all(self):
        """–ó–∞–∫—Ä—ã—Ç–∏–µ –≤—Å–µ—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π —Å –±–∏—Ä–∂–∞–º–∏"""
        for exchange in self.exchanges.values():
            try:
                await exchange.close()
            except Exception as e:
                logger.error(f"Error closing exchange: {e}")

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä —Å–µ—Ä–≤–∏—Å–∞
ccxt_service = CCXTService()

# === UTILITY FUNCTIONS ===
def normalize_symbol(symbol: str) -> str:
    """–ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏–º–≤–æ–ª–∞ –¥–ª—è CCXT"""
    # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º BTCUSDT -> BTC/USDT
    if '/' not in symbol and len(symbol) >= 6:
        # –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º —á—Ç–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 4 —Å–∏–º–≤–æ–ª–∞ - —ç—Ç–æ quote currency
        if symbol.endswith('USDT'):
            base = symbol[:-4]
            quote = symbol[-4:]
            return f"{base}/{quote}"
        elif symbol.endswith('BTC') or symbol.endswith('ETH'):
            base = symbol[:-3]
            quote = symbol[-3:]
            return f"{base}/{quote}"
    
    return symbol

def ccxt_to_chartgenius_format(ohlcv_data: List[List[float]]) -> List[Dict[str, Any]]:
    """–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ CCXT —Ñ–æ—Ä–º–∞—Ç–∞ –≤ —Ñ–æ—Ä–º–∞—Ç ChartGenius"""
    result = []
    
    for candle in ohlcv_data:
        if len(candle) >= 5:
            result.append({
                'timestamp': int(candle[0]),
                'open': float(candle[1]),
                'high': float(candle[2]),
                'low': float(candle[3]),
                'close': float(candle[4]),
                'volume': float(candle[5]) if len(candle) > 5 else 0.0
            })
    
    return result
